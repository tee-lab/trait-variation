import numpy as np
import math
import pandas as pd
from scipy.stats import uniform
import time


def cust_range(*args, rtol=1e-05, atol=1e-08, include=[True, False]):
    """
    Combines numpy.arange and numpy.isclose to mimic
    open, half-open and closed intervals.
    Avoids also floating point rounding errors as with
    >>> numpy.arange(1, 1.3, 0.1)
    array([1. , 1.1, 1.2, 1.3])

    args: [start, ]stop, [step, ]
        as in numpy.arange
    rtol, atol: floats
        floating point tolerance as in numpy.isclose
    include: boolean list-like, length 2
        if start and end point are included
    """
    # process arguments
    if len(args) == 1:
        start = 0
        stop = args[0]
        step = 1
    elif len(args) == 2:
        start, stop = args
        step = 1
    else:
        assert len(args) == 3
        start, stop, step = tuple(args)

    # determine number of segments
    n = (stop-start)/step + 1

    # do rounding for n
    if np.isclose(n, np.round(n), rtol=rtol, atol=atol):
        n = np.round(n)

    # correct for start/end is exluded
    if not include[0]:
        n -= 1
        start += step
    if not include[1]:
        n -= 1
        stop -= step

    return np.linspace(start, stop, int(n))

def crange(*args, **kwargs):
    return cust_range(*args, **kwargs, include=[True, True])

def orange(*args, **kwargs):
    return cust_range(*args, **kwargs, include=[True, False])

print('crange(1, 1.3, 0.1) >>>', crange(1, 1.3, 0.1))

def omega(G,th):  
    return 0.9 + (0.05-0.9)/(1+math.exp((th-G)/0.005))

Gseq = np.arange(0,1.05,0.05) 
Gseq = [round(i,2) for i in Gseq]
Bseq = Gseq
df_th = pd.DataFrame({'Gi':Gseq})

for i in Bseq:
    df_th[i] = 0
    
df_th_T = df_th

for r in Gseq: 
  for b in Bseq:
    bins = 100
    min_var = 0
    max_var = 1
    th = list(np.arange(min_var, max_var,0.0001))
    a =  np.empty(bins)
    l = uniform.pdf(th)
    q= list(crange(0.005,0.995,(1/bins)))
    v = range(0,bins,1)
    for i in v:
        a[i]=st.mean(l[int(((i)*((len(th)-1)/bins))):int(((i+1)*((len(th)-1)/bins)+1))])
        a[i] = (a[i]*uniform.pdf(q[i],min_var,max_var))
    p = a/sum(a)
    x = 1000
    pr = p*x
    a_beta1 = np.empty(0)
    for i in range(0,len(pr)):
        ab = np.array([q[i]]*int(pr[i]))
        a_beta1 = np.append(a_beta1,ab)
    d= len(a_beta1)
    Gi = G0 = r
    S0 = T0 = (1-G0)/2
    b, u, v = 0.35, 0.1, 0.1
    S_t = Si = [S0/d for i in range(0,d)]
    T_t = Ti = [T0/d for i in range(0,d)]
    G = [G0 for i in range(0,d)]
    tim = 200
    dt = 0.001
    timesteps = int(tim/dt)
    df = pd.DataFrame(a_beta1, columns=['th'])
    df['FinS'] = Si
    df['FinT'] = Ti
    a =  numeric(bins)
    for (i in 1:bins) {
    a[i]=mean(l[((i-1)*((length(th)-1)/bins) +1):((i)*((length(th)-1)/bins)+1)])
    a[i] = (a[i]*dunif(q[i],0,1))
    }

    Gi = G0 = r
    S0 = T0 = (1-G0)/2
    u, v = 0.1, 0.1
    S_t = Si = [S0/d for i in range(0,d)]
    T_t = Ti = [T0/d for i in range(0,d)]
    G = [G0 for i in range(0,d)]
    tim = 300
    dt = 0.001
    timesteps = int(tim/dt)
    df = pd.DataFrame(a_beta1, columns=['th'])
    df['FinS'] = Si
    df['FinT'] = Ti
    tic1 = time.process_time()
    for t in range(0,timesteps):
        G_t=G0+(u*S0 + v*T0 - b*G0*T0)*dt
        for i in q:
            z1=df[df['th']==i].index.tolist()
            z1[0]
            S_i = df.loc[z1[0],'FinS'] + (b*G0*df.loc[z1[0],'FinT'] - omega(G0,i)*df.loc[z1[0],'FinS'] - u*df.loc[z1[0],'FinS'])*dt;
            T_i = df.loc[z1[0],'FinT']+ (omega(G0,i)*df.loc[z1[0],'FinS'] - v*df.loc[z1[0],'FinT'])*dt; 
        
            df.loc[z1,'FinS']= S_i
            df.loc[z1,'FinT'] = T_i
            
        G0 = G_t
        S0 = sum(df.loc[:,'FinS'])
        T0 = sum(df.loc[:,'FinT'])
    toc1 = time.process_time()
    print(toc1 - tic1)
    z=df_th[df_th['Gi']==r].index.tolist()
    df_th.loc[z[0],b]= G0
    df_th_T.loc[z[0],b]= T0
    
